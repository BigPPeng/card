[## Leetcode 287 寻找重复数](https://mp.weixin.qq.com/s?__biz=MzIxMzI0MjM5Mg==&mid=2654893781&idx=1&sn=5cf02336b080f209c5c78a999bf08707&chksm=8c7311a2bb0498b4032c67ef35bfab8c4d39c2304fad1c3710494bd339bf20a8359b43887fdf&token=1961178180&lang=zh_CN#rd)

给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。

**示例 1:**

```java
输入: [1,3,4,2,2]
输出: 2
示例 2:

输入: [3,1,3,4,2]
输出: 3
说明：
```
- 不能更改原数组（假设数组是只读的）。
- 只能使用额外的 O(1) 的空间。
- 时间复杂度小于 O(n2) 。
- 数组中只有一个重复的数字，但它可能不止重复出现一次。
## 题意分析
1. 给定长度为 n 的整数数组，元素值范围 在 1 到 n - 1 的闭区间。
2. 数组元素值只有一个是有重复存在的，同时有一个或者多个，而其它值则只有 1 个或者 0 个。
3. 数组只能读不能更改原数组，指不能进行排序、普通的位置交换以及重新赋值等操作。
4. 只能使用额外 O(1) 的空间，指不能使用额外的容器进行数据拷贝，而只能使用常量级的变量记录。
5. 时间复杂度要小于 O(n^2) ，表示循环次数要控制在双层暴力循环之内。

## 快慢指针
1. 为什么能成环？

从头遍历数组，通过元素值指向下一个遍历位置，可以根据题目可知，能找到两个不同的索引（但是值相等）指向同一索引，**这就成环**
例如下图中的 nums[2]和nums[10]**要找的值** 都指nums[3]**环入口**
 [](https://pic.leetcode-cn.com/b44295c0410631fdd8aafe5fc657d4ed40acd6c0b007abc82c335c3df4de5bf7.gif)

2. 定义快慢指针分别以每次两步和每次一步遍历数组，因为有环的存在，所以两指针一定会相遇，这个点叫**相遇点**。且快指针步数为慢指针的二倍。

3. 我们要找的是**环入口**，为啥先找**相遇点**？

假设：（根据箭头指定的方向）指针从**起点** 走到**环入口** 要走M步；从**环入口**走到**相遇点**需要S步；走完一个环需要L步，k为快指针走的环数，快指针从**起点**走到**环入口**相对步数 L-S

慢指针步数=M+S；

快指针步数=M+S+k*L=2(M+S)

由此可以得出 M=k*L-S=(k-1)L+L-S;

由此可以得出 M=(k-1)*L+L-S;这就说明快慢指针步调相同后；慢指针从 **起点** 走到 **环入口** 与快指针从 **相遇点**走到 **环入口**能同时到达。
这就找到了 **环入口**
 [](https://pic.leetcode-cn.com/b356ff5ad63eb93424aca931be2459cd19d6f1d03557cc1a5f72b861437040c0.gif)

## Java代码

```Java
/*
*@author IT面试小典 
*@2020/5/26 14:58  
* 学习
*/
class Solution {
    public int findDuplicate(int[] nums) {
        if(nums.length <= 2){
            return nums[0];
        }
        //第一步找到相遇点
        //慢指针走一步nums[i];
        //快指针走两步nums[nums[j]]
        int i = 0,j = 0;
        while(true){
            i = nums[i];
            j = nums[nums[j]];
            if(i == j)  { break;}
        }
        //慢指针归位
        i = 0;
        //快指针调整步调
        while(true){
            i = nums[i];
            j = nums[j];
            if(i == j) break;
        }
        return i; 
      
    }
}
```
## 复杂度分析
- 时间复杂度：O(n)。「Floyd 判圈算法」时间复杂度为线性的时间复杂度。

- 空间复杂度：O(1)。我们只需要常数空间存放若干变量。
## 运行结果

 [](https://pic.leetcode-cn.com/5d10393e54d3e12febeda8b0c92e457fad433c9a55de5a11c84fa3e4c53c09e9.jpg)







